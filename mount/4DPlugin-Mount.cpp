/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Mount.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Mount
 #	author : miyako
 #	2019/10/02
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Mount.h"

#import <Cocoa/Cocoa.h>

#pragma mark -

#define CALLBACK_SLEEP_TIME 59

std::mutex globalMutex; /* PATHS,LISTENER_CONTEXT */
std::mutex globalMutex1;/* for METHOD_PROCESS_ID */
std::mutex globalMutex2;/* for LISTENER_METHOD */
std::mutex globalMutex3;/* PROCESS_SHOULD_TERMINATE */
std::mutex globalMutex4;/* PROCESS_SHOULD_RESUME */

namespace mount
{
    Listener *listener = nil;
    
    //constants
    process_stack_size_t STACK_SIZE = 0;
    PA_Unichar PROCESS_NAME_C[] = {'$', 'm', 'o', 'u', 'n', 't' , 0};
    const process_name_t PROCESS_NAME = (PA_Unichar *)PROCESS_NAME_C;
    
    //context management
    std::vector<CUTF16String>USER_INFO;
    
    //callback management
    C_TEXT LISTENER_METHOD;
    process_number_t METHOD_PROCESS_ID = 0;
    bool PROCESS_SHOULD_TERMINATE = false;
    bool PROCESS_SHOULD_RESUME = false;
}

void listener_start()
{
    if(!mount::listener)
    {
        mount::listener = [[Listener alloc]init];
    }
}

void listener_end()
{
    [mount::listener release];
    mount::listener = nil;
}

void listenerLoop()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        mount::PROCESS_SHOULD_TERMINATE = false;
    }
    
    /* Current process returns 0 for PA_NewProcess */
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    
    while(!PA_IsProcessDying())
    {
        PA_YieldAbsolute();
        
        bool PROCESS_SHOULD_RESUME;
        bool PROCESS_SHOULD_TERMINATE;
        
        if(1)
        {
            PROCESS_SHOULD_RESUME = mount::PROCESS_SHOULD_RESUME;
            PROCESS_SHOULD_TERMINATE = mount::PROCESS_SHOULD_TERMINATE;
        }
        
        if(PROCESS_SHOULD_RESUME)
        {
            size_t number_of_events;
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex);
                
                number_of_events = mount::USER_INFO.size();
            }
            
            
            while(number_of_events)
            {
                PA_YieldAbsolute();
                
                listenerLoopExecuteMethod();
                
                if (PROCESS_SHOULD_TERMINATE)
                    break;
                
                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex);
                    
                    number_of_events = mount::USER_INFO.size();
                    PROCESS_SHOULD_TERMINATE = mount::PROCESS_SHOULD_TERMINATE;
                }
            }
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex4);
                
                mount::PROCESS_SHOULD_RESUME = false;
            }
            
        }else
        {
            /* DELAY PROCESS does not work for PA_NewProcess */
            PA_PutProcessToSleep(currentProcessNumber, CALLBACK_SLEEP_TIME);
        }
        
        if(1)
        {
            PROCESS_SHOULD_TERMINATE = mount::PROCESS_SHOULD_TERMINATE;
        }
        
        if (PROCESS_SHOULD_TERMINATE)
            break;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        mount::USER_INFO.clear();
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        mount::LISTENER_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        mount::METHOD_PROCESS_ID = 0;
    }
    
    PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_end, NULL);
    
    PA_KillProcess();
}

void listenerLoopStart()
{
    if(!mount::METHOD_PROCESS_ID)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        mount::METHOD_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
                                                 mount::STACK_SIZE,
                                                 mount::PROCESS_NAME);
    }
}

void listenerLoopFinish()
{
    if(mount::METHOD_PROCESS_ID)
    {
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex3);
            
            mount::PROCESS_SHOULD_TERMINATE = true;
        }
        
        PA_YieldAbsolute();
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex4);
            
            mount::PROCESS_SHOULD_RESUME = true;
        }
    }
}

void listenerLoopExecute()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        mount::PROCESS_SHOULD_TERMINATE = false;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex4);
        
        mount::PROCESS_SHOULD_RESUME = true;
    }
    
}

void listenerLoopExecuteMethod()
{
    CUTF16String USER_INFO;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        std::vector<CUTF16String>::iterator p;
        
        p = mount::USER_INFO.begin();
        
        USER_INFO = *p;
        
        mount::USER_INFO.erase(p);
    }
    
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)mount::LISTENER_METHOD.getUTF16StringPtr());
    
    if(methodId)
    {
        PA_Variable    params[1];
        
        params[0] = PA_CreateVariable(eVK_Unistring);
        PA_Unistring userInfo = PA_CreateUnistring((PA_Unichar *)USER_INFO.c_str());
        PA_SetStringVariable(&params[0], &userInfo);
        
        PA_ExecuteMethodByID(methodId, params, 1);
        PA_ClearVariable(&params[0]);
        
    }else
    {
        PA_Variable    params[2];
        
        params[1] = PA_CreateVariable(eVK_Unistring);
        PA_Unistring userInfo = PA_CreateUnistring((PA_Unichar *)USER_INFO.c_str());
        PA_SetStringVariable(&params[1], &userInfo);

        params[0] = PA_CreateVariable(eVK_Unistring);
        PA_Unistring method = PA_CreateUnistring((PA_Unichar *)mount::LISTENER_METHOD.getUTF16StringPtr());
        PA_SetStringVariable(&params[0], &method);
        
        PA_ExecuteCommandByID(1007/* execute method */, params, 2);
        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);
    }
}

@implementation Listener

- (id)init
{
    if(!(self = [super init])) return self;
    
    _notificationCenter = [[NSWorkspace sharedWorkspace]notificationCenter];
   
    [_notificationCenter
     addObserver:self
     selector: @selector(didMountNotification:)
     name:NSWorkspaceDidMountNotification
     object:nil];

    [_notificationCenter
     addObserver:self
     selector: @selector(willUnmountNotification:)
     name:NSWorkspaceWillUnmountNotification
     object:nil];
    
    [_notificationCenter
     addObserver:self
     selector: @selector(didUnmountNotification:)
     name:NSWorkspaceDidUnmountNotification
     object:nil];

    [_notificationCenter
     addObserver:self
     selector: @selector(didRenameVolumeNotification:)
     name:NSWorkspaceDidRenameVolumeNotification
     object:nil];
    
    return self;
}

- (void)dealloc
{
    [[[NSWorkspace sharedWorkspace] notificationCenter]removeObserver:self];
    
    [super dealloc];
}

- (void)didMountNotification:(NSNotification *)notification
{
   [self call:didMountNotificationEvent notification:notification];
}

- (void)willUnmountNotification:(NSNotification *)notification
{
   [self call:willUnmountNotificationEvent notification:notification];
}

- (void)didUnmountNotification:(NSNotification *)notification
{
   [self call:didUnmountNotificationEvent notification:notification];
}

- (void)didRenameVolumeNotification:(NSNotification *)notification
{
    [self call:didRenameVolumeNotificationEvent notification:notification];
}

- (void)call:(mount_event_id_t)event notification:(NSNotification *)notification
{
    Json::Value userInfo;
    userInfo["type"] = event;
    
    NSDictionary *dict = [notification userInfo];

    NSURL *volumeURL = [dict objectForKey:NSWorkspaceVolumeURLKey];
    NSString *volumePath = (NSString *)CFURLCopyFileSystemPath((CFURLRef)volumeURL, kCFURLHFSPathStyle);
    userInfo["volumePath"] = [volumePath UTF8String];
    userInfo["volumeURL"] = [[volumeURL absoluteString]UTF8String];
    [volumePath release];
    
    NSString *volumeLocalizedName = [dict objectForKey:NSWorkspaceVolumeLocalizedNameKey];
    userInfo["volumeLocalizedName"] = [volumeLocalizedName UTF8String];
    
    NSURL *volumeOldURL;
    NSString *volumeOldPath;
 
    
    
    switch (event)
    {
        case didMountNotificationEvent:
            userInfo["devicePath"] = [[dict objectForKey:@"NSDevicePath"]UTF8String];
            break;
            
        case willUnmountNotificationEvent:
            userInfo["devicePath"] = [[dict objectForKey:@"NSDevicePath"]UTF8String];
            break;
            
        case didUnmountNotificationEvent:
            userInfo["devicePath"] = [[dict objectForKey:@"NSDevicePath"]UTF8String];
            break;
            
        case didRenameVolumeNotificationEvent:
            userInfo["volumeOldLocalizedName"] = [[dict objectForKey:NSWorkspaceVolumeOldLocalizedNameKey]UTF8String];
            volumeOldURL = [dict objectForKey:NSWorkspaceVolumeOldURLKey];
            volumeOldPath = (NSString *)CFURLCopyFileSystemPath((CFURLRef)volumeOldURL, kCFURLHFSPathStyle);
            userInfo["volumeOldPath"] = [volumeOldPath UTF8String];
            userInfo["volumeOldURL"] = [[volumeOldURL absoluteString]UTF8String];
            [volumeOldPath release];
            break;
    }
    
    Json::StreamWriterBuilder builder;
    std::string json = Json::writeString(builder, userInfo);
    
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault,
                                              (const UInt8 *)json.c_str(),
                                              json.length(),
                                              kCFStringEncodingUTF8, true);
    if(str){
        CFIndex len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        CUTF16String u((const PA_Unichar *)&buf[0]);
        CFRelease(str);
        mount::USER_INFO.push_back(u);
        listenerLoopExecute();
    }

}

@end

#define MAX_PROCESS_NAME 1024

bool IsProcessOnExit()
{
    PA_long32 state, time;
    
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    PA_Variable name = PA_GetProcessInfo_s(currentProcessNumber, &state, &time);
    PA_Unistring u = PA_GetStringVariable(name);
    CUTF16String procName(u.fString, u.fLength);
    PA_Unichar _exitProcName[] = {'$', 'x', 'x', 0};
    CUTF16String exitProcName((PA_Unichar *)_exitProcName);
    bool isProcessOnExit = (!procName.compare(exitProcName));
    PA_ClearVariable(&name);
    
    return isProcessOnExit;
}

void OnStartup()
{

}

void OnCloseProcess()
{
    if(IsProcessOnExit())
    {
        listenerLoopFinish();
    }
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                
            case kCloseProcess :
                OnCloseProcess();
                break;
                
			// --- Mount
            
			case 1 :
				Mount_WATCH(params);
				break;
			case 2 :
//                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)Unmount, params);
                Unmount(params);
				break;
			case 3 :
//                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)Mount, params);
				Mount(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void Mount_WATCH(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    if(!IsProcessOnExit())
    {
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex2);
            
            mount::LISTENER_METHOD.fromParamAtIndex(pParams, 1);
            
            if(mount::LISTENER_METHOD.getUTF16Length()){
                
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_start, NULL);
                listenerLoopStart();
                
            }else{
                listenerLoopFinish();
            }

        }
        
    }
    
}

static void OnDiskUnmount(DADiskRef disk, DADissenterRef dissenter, void* context)
{
    if (dissenter)
    {
        // error
    }
    else
    {
        // success
    }
}

void Unmount(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT t, r;
    t.fromParamAtIndex(pParams, 1);
    NSURL *url = t.copyUrl();
    
    if(url) {
        DASessionRef session = DASessionCreate(kCFAllocatorDefault);
        if(session) {
            
            DADiskRef diskRef = DADiskCreateFromVolumePath(kCFAllocatorDefault, session, (CFURLRef)url);
            if(diskRef) {
                
                const char *BSDName = DADiskGetBSDName(diskRef);
                
                r.setUTF8String((const uint8_t *)BSDName, (uint32_t)strlen(BSDName));
                r.setReturn(pResult);
                
                DADiskUnmount(diskRef,
                            kDADiskUnmountOptionForce,
                            OnDiskUnmount,
                            NULL);
                
                CFRelease(diskRef);
            }
            CFRelease(session);
        }
        [url release];
    }
}

static void OnDiskMount(DADiskRef disk, DADissenterRef dissenter, void* context)
{
    if (dissenter)
    {
        // error
    }
    else
    {
        // success
    }
}

void Mount(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT t;
    t.fromParamAtIndex(pParams, 1);
    NSString *name = t.copyUTF16String();
    
    if(name) {
        DASessionRef session = DASessionCreate(kCFAllocatorDefault);
        if(session) {
            
            DADiskRef diskRef = DADiskCreateFromBSDName(kCFAllocatorDefault, session, [name UTF8String]);
            
            if(diskRef) {
                
                DADiskMount(diskRef,
                            NULL,
                            kDADiskMountOptionDefault,
                            OnDiskMount,
                            NULL);
                
                CFRelease(diskRef);
            }
            CFRelease(session);
        }
        [name release];
    }
 
}

